iostat -xm 5 #io
vmstat 1 #cpu

QUICK SUMMARY
CPU time is the first thing to examine when looking at performance of an application.
The goal in optimizing code is to drive the CPU usage up (for a shorter period of time), not down.
Understand why CPU usage is low before diving in and attempting to tune an application.

QUICK SUMMARY
Monitoring disk usage is important for all applications. For applications that donât directly write to disk, system swapping can still affect their performance.
Applications that write to disk can be bottlenecked both because they are writing data inefficiently (too little throughput) or because they are writing too much data (too much throughput).


nicstat 5 # network

QUICK SUMMARY
For network-based applications, make sure to monitor the network to make sure it hasnât become a bottleneck.
Applications that write to the network can be bottlenecked both because they are writing data inefficiently (too little throughput) or because they are writing too much data (too much throughput).


JVM tools
jcmd 43483 PerfCounter.print

jconsole
Provides a graphical view of JVM activities, including thread usage, class usage, and GC activities
jhat
Reads and helps analyze memory heap dumps. This is a post-processing utility.
jmap
Provides heap dumps and other information about JVM memory usage. Suitable for scripting, though the heap dumps must be used in a post-processing tool.
jinfo
Provides visibility into the system properties of the JVM, and allows some system properties to be set dynamically. Suitable for scripting.
jstack
Dumps the stacks of a Java process. Suitable for scripting.
jstat
Provides information about GC and class loading activities. Suitable for scripting.
jvisualvm
A GUI tool to monitor a JVM, profile a running application, and analyze JVM heap dumps (which is a post-processing activity, though jvisualvm can also take the heap dump from a live program).


jcmd 51449 VM.uptime
jcmd 51449 VM.system_properties
jcmd 51449 VM.version
jcmd 51449 VM.command_line
jcmd 51449 VM.flagsjcmd 51449 VM.flags -all

java other_options -XX:+PrintFlagsFinal -version

sudo jinfo -flags 60816
jinfo -flag PrintGCDetails 60816
java -XX:+PrintFlagsFinal -jar appd-showcase-weather-app.jar
jcmd 81840 Thread.print

jcmd 81840 VM.unlock_commercial_features
jcmd 81840 JFR.start
jcmd 81840 JFR.dump recording=1 filename=/tmp/rec1.jfr
jcmd pid GC.run

-XX:-TieredCompilation

assembly code cache is full, can be monitored via Memory Pool Code Cache in jconsole
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full.
         Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the
         code cache size using -XX:ReservedCodeCacheSize=

from java 11 code cache is split in 3 parts

-XX:NonNMethodCodeHeapSize=N: for the nonmethod code

-XX:ProfiledCodeHapSize=N for the profiled code

-XX:NonProfiledCodeHapSize=N for the nonprofiled code

-XX:+PrintCompilation
jstat -compiler 5003
jstat -printcompilation 24144 1000

0
Interpreted code

1
Simple C1 compiled code

2
Limited C1 compiled code

3
Full C1 compiled code

4
C2 compiled code
------------compilation flags-----------
-XX:CompileThreshold=N, default n = 10000 (makes sense in JDK =<7)

-XX:Tier3InvocationThreshold=N (default 200) to get C1 to compile a method more quickly
-XX:Tier4InvocationThreshold=N (default 5000) to get C2 to compile a method more quickly
-XX:CICompilerCount=N
-XX:+BackgroundCompilation
---------------inlining flags-----------------
-XX:-Inline
-XX:+PrintInlining (if JVM bult from source)
-XX:MaxFreqInlineSize=N
-XX:MaxInlineSize=N
-----------escape analysis------------
-XX:+DoEscapeAnalysis, which is true by default
------------CPU-specific code-------------------
-XX:UseAVX=2
-XX:UseSSE=N
------------tiered compilation--------
-XX:-TieredCompilation
-XX:+TieredCompilation

The -g option to include additional debugging information doesnât affect performance.
Using the final keyword in your Java program doesnât produce faster compiled code.
Recompiling with newer javac versions doesnât (usually) make programs any faster.

------------graalVM--------------
-XX:+UnlockExperimentalVMOptions, -XX:+EnableJVMCI, and -XX:+UseJVMCICompiler. The default for all those flags is false.

----------AOT compilation----------------

jaotc --compile-commands=/tmp/methods.txt \
    --output JavaBaseFilteredMethods.so \
    --compile-for-tiered \ #- makes eligible for C2 compilation 
    --module java.base

java -XX:+UnlockDiagnosticVMOptions -XX:+LogTouchedMethods \
      -XX:+PrintTouchedMethodsAtExit <other arguments>

java -XX:AOTLibrary=/path/to/JavaBaseFilteredMethods.so <other args>

-XX:+PrintAOT

---------------==============Garbage collection=========---------------------
Enable serial collector - stops for old/young
-XX:+UseSerialGC
Enable parallel/throughput collector - also stops
-XX:+UseParallelGC
G1 GC - divides heap into regions, doesn't stop for collecting old gen, can compact OOTB
-XX:+UseG1GC      
CMS - has to stop to compact, replaced by G1GC
-XX:+UseConcMarkSweepGC
prevent jvm from responding to System.gc() calls that will do full GC
-XX:+DisableExplicitGC
---------====================GC Tuning==============-----------------------
-XmsN initial heap size
-XmxN maximum heap size

A good rule of thumb is to size the heap so that it is 30% occupied after a full GC. 
To calculate this, run the application until it has reached a steady-state configuration: a point at which it has loaded anything it caches, 
has created a maximum number of client connections, and so on. Then connect to the application with jconsole, force a full GC, 
and observe how much memory is used when the full GC completes. (Alternately, for throughput GC, you can consult the GC log if it is available.) 
If you take that approach, make sure to size your container (if applicable) to have an additional 0.5â1 GB of memory for nonheap needs of the JVM.
-XX:NewRatio=N
Set the ratio of the young generation to the old generation.

-XX:NewSize=N
Set the initial size of the young generation.

-XX:MaxNewSize=N
Set the maximum size of the young generation.

-XmnN
Shorthand for setting both NewSize and MaxNewSize to the same value.
-XX:NewRatio=N
Set the ratio of the young generation to the old generation.

Initial Young Gen Size = Initial Heap Size / (1 + NewRatio)

-XX:-UseAdaptiveSizePolicy
adaptive sizing is also effectively turned off if the minimum and maximum heap sizes are set to the same value, 
and the initial and maximum sizes of the new generation are set to the same value
-XX:+PrintAdaptiveSizePolicy
-XX:MaxGCPauseMillis=N
-XX:GCTimeRatio=N
T h r o u g h p u t G o a l = 1 - 1 (1+GCTimeRatio)
G C T i m e R a t i o = Throughput (1-Throughput)

------======Metaspace=======-------
-XX:MetaspaceSize=N
-XX:MaxMetaspaceSize=N
jmap -clstats 52431 //classloader info

-----=======Parallelism=======---

-XX:ParallelGCThreads=N

ParallelGCThreads = 8 + ((N - 8) * 5 / 8)

-----======GC logging======--------
-verbose:gc or -XX:+PrintGC
-XX:+PrintGCDetails //more details
-XX:+PrintGCTimeStamps or -XX:+PrintGCDateStamps //The difference in those two arguments is that the timestamps are relative to 0 (based on when the JVM starts), while the date stamps are an actual date string
-Xloggc:filename flag. Using -Xloggc automatically enables the simple GC log unless PrintGCDetails has also been enabled.
-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=N -XX:GCLogFileSize=N
-Xloggc:gc.log -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFile=8 -XX:GCLogFileSize=8m
4 JDK >=11
-Xlog:gc*:file=gc.log:time:filecount=7,filesize=8M //gc*,gc+age=debug
jClarity (Censum) and GCeasy to analyze GC logs
For real-time monitoring of the heap, use jvisualvm or jconsole

jstat -gcutil 13607 1000
------======tuning G1====-------
-XX:MaxGCPauseMillis=N //200 ms default
-XX:ParallelGCThreads=N  //adjust the number of background threads
-XX:ConcGCThreads=N //threads used for remarking
ConcGCThreads = (ParallelGCThreads + 2) / 4
-XX:InitiatingHeapOccupancyPercent=N //default value 45%
-XX:G1MixedGCCountTarget=N //The default value for that is 8
----=======Advanced Tuning=======--------
-XX:InitialSurvivorRatio=N
survivor_space_size = new_size / (initial_survivor_ratio + 2) //survivor_space_size = new_size / (initial_survivor_ratio + 2)
//To keep the survivor spaces at a fixed size, set the SurvivorRatio to the desired value and disable the UseAdaptiveSizePolicy flag (though remember that disabling adaptive sizing will apply to the old and new generations as well).
-XX:TargetSurvivorRatio=N
-XX:InitialTenuringThreshold=N flag (the default is 7 for the throughput and G1 GC collectors, and 6 for CMS)
-XX:MaxTenuringThreshold=N flag; for the throughput and G1 GC collectors, the default maximum threshold is 15, and for CMS it is 6.
-XX:+AlwaysTenure //This is a rare situation; it means that objects will always be promoted to the old generation rather than stored in a survivor space.
-XX:+NeverTenure (also false by default).// This flag affects two things: it behaves as if the initial and max tenuring thresholds are infinity, and it prevents the JVM from adjusting that threshold down. In other words, as long as there is room in the survivor space, no object will ever be promoted to the old generation.
 -XX:+PrintTenuringDistribution (which is false by default). In JDK 11, it is added by including age*=debug or age*=trace to the Xlog argument.
 
 -XX:-UseTLAB
  -XX:+PrintTLAB //tlab*=trace 
  -XX:TLABSize=N (the default value, 0, means to use the dynamic calculation previously described)
  -XX:-ResizeTLAB (the default for that flag is true)
  -XX:TLABWasteTargetPercent=N
  -XX:TLABWasteIncrement=N (the default is 4)
  -XX:MinTLABSize=N (the default is 2 KB)
  -------===========G1 regions========--------
  region_size = 1 << log(Initial Heap Size / 2048);
  -XX:G1HeapRegionSize=N flag (the default is nominally 0, meaning to use the dynamic value just described)
  select a value so that there will be close to 2,048 regions at the expected heap size.
  
  AggressiveHeap flag (by default, false
  -XX:MaxRAM=N
  Default Xmx = MaxRAM / MaxRAMFraction
  The maximum heap size is one-quarter of MaxRAM
  -XX:MaxRAMFraction=N flag, which defaults to 4
  -XX:ErgoHeapSizeLimit=N flag can also be set to a maximum default value that the JVM should use. That value is 0 by default (meaning to ignore it); otherwise, that limit is used if it is smaller than MaxRAM / MaxRAMFraction.
  Default Xms =  MaxRAM / InitialRAMFraction //default value of the InitialRAMFraction flag is 64
  
  POLICY OVER CHOOSING A PROPER GC ALGORITHM
  Can your application tolerate some full GC pauses?
If not, G1 GC is the algorithm of choice. Even if you can tolerate some full pauses, G1 GC will often be better than parallel GC unless your application is CPU bound.

Are you getting the performance you need with the default settings?
Try the default settings first. As GC technology matures, the ergonomic (automatic) tuning gets better all the time. If youâre not getting the performance you need, make sure that GC is your problem. Look at the GC logs and see how much time youâre spending in GC and how frequently the long pauses occur. For a busy application, if youâre spending 3% or less time in GC, youâre not going to get a lot out of tuning (though you can always try to reduce outliers if that is your goal).

Are the pause times that you have somewhat close to your goal?
If they are, adjusting the maximum pause time may be all you need. If they arenât, you need to do something else. If the pause times are too large but your throughput is OK, you can reduce the size of the young generation (and for full GC pauses, the old generation); youâll get more, but shorter, pauses.

Is throughput lagging even though GC pause times are short?
You need to increase the size of the heap (or at least the young generation). More isnât always better: bigger heaps lead to longer pause times. Even with a concurrent collector, a bigger heap means a bigger young generation by default, so youâll see longer pause times for young collections. But if you can, increase the heap size, or at least the relative sizes of the generations.

Are you using a concurrent collector and seeing full GCs due to concurrent-mode failures?
If you have available CPU, try increasing the number of concurrent GC threads or starting the background sweep sooner by adjusting InitiatingHeapOccupancyPercent. For G1, the concurrent cycle wonât start if there are pending mixed GCs; try reducing the mixed GC count target.

Are you using a concurrent collector and seeing full GCs due to promotion failures?
In G1 GC, an evacuation failure (to-space overflow) indicates that the heap is fragmented, but that can usually be solved if G1 GC performs its background sweeping sooner and mixed GCs faster. Try increasing the number of concurrent G1 threads, adjusting InitiatingHeapOccupancyPercent, or reducing the mixed GC count target.