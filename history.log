iostat -xm 5 #io
vmstat 1 #cpu

QUICK SUMMARY
CPU time is the first thing to examine when looking at performance of an application.
The goal in optimizing code is to drive the CPU usage up (for a shorter period of time), not down.
Understand why CPU usage is low before diving in and attempting to tune an application.

QUICK SUMMARY
Monitoring disk usage is important for all applications. For applications that donât directly write to disk, system swapping can still affect their performance.
Applications that write to disk can be bottlenecked both because they are writing data inefficiently (too little throughput) or because they are writing too much data (too much throughput).


nicstat 5 # network

QUICK SUMMARY
For network-based applications, make sure to monitor the network to make sure it hasnât become a bottleneck.
Applications that write to the network can be bottlenecked both because they are writing data inefficiently (too little throughput) or because they are writing too much data (too much throughput).


JVM tools
jcmd 43483 PerfCounter.print

jconsole
Provides a graphical view of JVM activities, including thread usage, class usage, and GC activities
jhat
Reads and helps analyze memory heap dumps. This is a post-processing utility.
jmap
Provides heap dumps and other information about JVM memory usage. Suitable for scripting, though the heap dumps must be used in a post-processing tool.
jinfo
Provides visibility into the system properties of the JVM, and allows some system properties to be set dynamically. Suitable for scripting.
jstack
Dumps the stacks of a Java process. Suitable for scripting.
jstat
Provides information about GC and class loading activities. Suitable for scripting.
jvisualvm
A GUI tool to monitor a JVM, profile a running application, and analyze JVM heap dumps (which is a post-processing activity, though jvisualvm can also take the heap dump from a live program).


jcmd 51449 VM.uptime
jcmd 51449 VM.system_properties
jcmd 51449 VM.version
jcmd 51449 VM.command_line
jcmd 51449 VM.flagsjcmd 51449 VM.flags -all

java other_options -XX:+PrintFlagsFinal -version

sudo jinfo -flags 60816
jinfo -flag PrintGCDetails 60816
java -XX:+PrintFlagsFinal -jar appd-showcase-weather-app.jar
jcmd 81840 Thread.print

jcmd 81840 VM.unlock_commercial_features
jcmd 81840 JFR.start
jcmd 81840 JFR.dump recording=1 filename=/tmp/rec1.jfr

-XX:-TieredCompilation

assembly code cache is full, can be monitored via Memory Pool Code Cache in jconsole
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full.
         Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the
         code cache size using -XX:ReservedCodeCacheSize=

from java 11 code cache is split in 3 parts

-XX:NonNMethodCodeHeapSize=N: for the nonmethod code

-XX:ProfiledCodeHapSize=N for the profiled code

-XX:NonProfiledCodeHapSize=N for the nonprofiled code

-XX:+PrintCompilation
jstat -compiler 5003
jstat -printcompilation 24144 1000

0
Interpreted code

1
Simple C1 compiled code

2
Limited C1 compiled code

3
Full C1 compiled code

4
C2 compiled code
------------compilation flags-----------
-XX:CompileThreshold=N, default n = 10000 (makes sense in JDK =<7)

-XX:Tier3InvocationThreshold=N (default 200) to get C1 to compile a method more quickly
-XX:Tier4InvocationThreshold=N (default 5000) to get C2 to compile a method more quickly
-XX:CICompilerCount=N
-XX:+BackgroundCompilation
---------------inlining flags-----------------
-XX:-Inline
-XX:+PrintInlining (if JVM bult from source)
-XX:MaxFreqInlineSize=N
-XX:MaxInlineSize=N
-----------escape analysis------------
-XX:+DoEscapeAnalysis, which is true by default
------------CPU-specific code-------------------
-XX:UseAVX=2
-XX:UseSSE=N
------------tiered compilation--------
-XX:-TieredCompilation
-XX:+TieredCompilation

The -g option to include additional debugging information doesnât affect performance.
Using the final keyword in your Java program doesnât produce faster compiled code.
Recompiling with newer javac versions doesnât (usually) make programs any faster.

------------graalVM--------------
-XX:+UnlockExperimentalVMOptions, -XX:+EnableJVMCI, and -XX:+UseJVMCICompiler. The default for all those flags is false.

----------AOT compilation----------------
jaotc --compile-commands=/tmp/methods.txt \
    --output JavaBaseFilteredMethods.so \
    --compile-for-tiered \ #- makes eligible for C2 compilation 
    --module java.base

java -XX:+UnlockDiagnosticVMOptions -XX:+LogTouchedMethods \
      -XX:+PrintTouchedMethodsAtExit <other arguments>

java -XX:AOTLibrary=/path/to/JavaBaseFilteredMethods.so <other args>

-XX:+PrintAOT
      