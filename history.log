iostat -xm 5 #io
vmstat 1 #cpu

QUICK SUMMARY
CPU time is the first thing to examine when looking at performance of an application.
The goal in optimizing code is to drive the CPU usage up (for a shorter period of time), not down.
Understand why CPU usage is low before diving in and attempting to tune an application.

QUICK SUMMARY
Monitoring disk usage is important for all applications. For applications that donât directly write to disk, system swapping can still affect their performance.
Applications that write to disk can be bottlenecked both because they are writing data inefficiently (too little throughput) or because they are writing too much data (too much throughput).


nicstat 5 # network

QUICK SUMMARY
For network-based applications, make sure to monitor the network to make sure it hasnât become a bottleneck.
Applications that write to the network can be bottlenecked both because they are writing data inefficiently (too little throughput) or because they are writing too much data (too much throughput).


JVM tools
jcmd 43483 PerfCounter.print

jconsole
Provides a graphical view of JVM activities, including thread usage, class usage, and GC activities
jhat
Reads and helps analyze memory heap dumps. This is a post-processing utility.
jmap
Provides heap dumps and other information about JVM memory usage. Suitable for scripting, though the heap dumps must be used in a post-processing tool.
jinfo
Provides visibility into the system properties of the JVM, and allows some system properties to be set dynamically. Suitable for scripting.
jstack
Dumps the stacks of a Java process. Suitable for scripting.
jstat
Provides information about GC and class loading activities. Suitable for scripting.
jvisualvm
A GUI tool to monitor a JVM, profile a running application, and analyze JVM heap dumps (which is a post-processing activity, though jvisualvm can also take the heap dump from a live program).


jcmd 51449 VM.uptime
jcmd 51449 VM.system_properties
jcmd 51449 VM.version
jcmd 51449 VM.command_line
jcmd 51449 VM.flagsjcmd 51449 VM.flags -all

java other_options -XX:+PrintFlagsFinal -version

sudo jinfo -flags 60816
jinfo -flag PrintGCDetails 60816
java -XX:+PrintFlagsFinal -jar appd-showcase-weather-app.jar
jcmd 81840 Thread.print

jcmd 81840 VM.unlock_commercial_features
jcmd 81840 JFR.start
jcmd 81840 JFR.dump recording=1 filename=/tmp/rec1.jfr
jcmd pid GC.run

-XX:-TieredCompilation

assembly code cache is full, can be monitored via Memory Pool Code Cache in jconsole
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full.
         Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the
         code cache size using -XX:ReservedCodeCacheSize=

from java 11 code cache is split in 3 parts

-XX:NonNMethodCodeHeapSize=N: for the nonmethod code

-XX:ProfiledCodeHapSize=N for the profiled code

-XX:NonProfiledCodeHapSize=N for the nonprofiled code

-XX:+PrintCompilation
jstat -compiler 5003
jstat -printcompilation 24144 1000

0
Interpreted code

1
Simple C1 compiled code

2
Limited C1 compiled code

3
Full C1 compiled code

4
C2 compiled code
------------compilation flags-----------
-XX:CompileThreshold=N, default n = 10000 (makes sense in JDK =<7)

-XX:Tier3InvocationThreshold=N (default 200) to get C1 to compile a method more quickly
-XX:Tier4InvocationThreshold=N (default 5000) to get C2 to compile a method more quickly
-XX:CICompilerCount=N
-XX:+BackgroundCompilation
---------------inlining flags-----------------
-XX:-Inline
-XX:+PrintInlining (if JVM bult from source)
-XX:MaxFreqInlineSize=N
-XX:MaxInlineSize=N
-----------escape analysis------------
-XX:+DoEscapeAnalysis, which is true by default
------------CPU-specific code-------------------
-XX:UseAVX=2
-XX:UseSSE=N
------------tiered compilation--------
-XX:-TieredCompilation
-XX:+TieredCompilation

The -g option to include additional debugging information doesnât affect performance.
Using the final keyword in your Java program doesnât produce faster compiled code.
Recompiling with newer javac versions doesnât (usually) make programs any faster.

------------graalVM--------------
-XX:+UnlockExperimentalVMOptions, -XX:+EnableJVMCI, and -XX:+UseJVMCICompiler. The default for all those flags is false.

----------AOT compilation----------------

jaotc --compile-commands=/tmp/methods.txt \
    --output JavaBaseFilteredMethods.so \
    --compile-for-tiered \ #- makes eligible for C2 compilation 
    --module java.base

java -XX:+UnlockDiagnosticVMOptions -XX:+LogTouchedMethods \
      -XX:+PrintTouchedMethodsAtExit <other arguments>

java -XX:AOTLibrary=/path/to/JavaBaseFilteredMethods.so <other args>

-XX:+PrintAOT

---------------==============Garbage collection=========---------------------
Enable serial collector - stops for old/young
-XX:+UseSerialGC
Enable parallel/throughput collector - also stops
-XX:+UseParallelGC
G1 GC - divides heap into regions, doesn't stop for collecting old gen, can compact OOTB
-XX:+UseG1GC      
CMS - has to stop to compact, replaced by G1GC
-XX:+UseConcMarkSweepGC
prevent jvm from responding to System.gc() calls that will do full GC
-XX:+DisableExplicitGC
---------====================GC Tuning==============-----------------------
-XmsN initial heap size
-XmxN maximum heap size

A good rule of thumb is to size the heap so that it is 30% occupied after a full GC. 
To calculate this, run the application until it has reached a steady-state configuration: a point at which it has loaded anything it caches, 
has created a maximum number of client connections, and so on. Then connect to the application with jconsole, force a full GC, 
and observe how much memory is used when the full GC completes. (Alternately, for throughput GC, you can consult the GC log if it is available.) 
If you take that approach, make sure to size your container (if applicable) to have an additional 0.5â1 GB of memory for nonheap needs of the JVM.
-XX:NewRatio=N
Set the ratio of the young generation to the old generation.

-XX:NewSize=N
Set the initial size of the young generation.

-XX:MaxNewSize=N
Set the maximum size of the young generation.

-XmnN
Shorthand for setting both NewSize and MaxNewSize to the same value.
-XX:NewRatio=N
Set the ratio of the young generation to the old generation.

Initial Young Gen Size = Initial Heap Size / (1 + NewRatio)

-XX:-UseAdaptiveSizePolicy
adaptive sizing is also effectively turned off if the minimum and maximum heap sizes are set to the same value, 
and the initial and maximum sizes of the new generation are set to the same value
-XX:+PrintAdaptiveSizePolicy
-XX:MaxGCPauseMillis=N
-XX:GCTimeRatio=N
T h r o u g h p u t G o a l = 1 - 1 (1+GCTimeRatio)
G C T i m e R a t i o = Throughput (1-Throughput)

------======Metaspace=======-------
-XX:MetaspaceSize=N
-XX:MaxMetaspaceSize=N
jmap -clstats 52431 //classloader info

-----=======Parallelism=======---

-XX:ParallelGCThreads=N

ParallelGCThreads = 8 + ((N - 8) * 5 / 8)

-----======GC logging======--------
-verbose:gc or -XX:+PrintGC
-XX:+PrintGCDetails //more details
-XX:+PrintGCTimeStamps or -XX:+PrintGCDateStamps //The difference in those two arguments is that the timestamps are relative to 0 (based on when the JVM starts), while the date stamps are an actual date string
-Xloggc:filename flag. Using -Xloggc automatically enables the simple GC log unless PrintGCDetails has also been enabled.
-XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=N -XX:GCLogFileSize=N
-Xloggc:gc.log -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFile=8 -XX:GCLogFileSize=8m
4 JDK >=11
-Xlog:gc*:file=gc.log:time:filecount=7,filesize=8M //gc*,gc+age=debug
jClarity (Censum) and GCeasy to analyze GC logs
For real-time monitoring of the heap, use jvisualvm or jconsole

jstat -gcutil 13607 1000
------======tuning G1====-------
-XX:MaxGCPauseMillis=N //200 ms default
-XX:ParallelGCThreads=N  //adjust the number of background threads
-XX:ConcGCThreads=N //threads used for remarking
ConcGCThreads = (ParallelGCThreads + 2) / 4
-XX:InitiatingHeapOccupancyPercent=N //default value 45%
-XX:G1MixedGCCountTarget=N //The default value for that is 8
----=======Advanced Tuning=======--------
-XX:InitialSurvivorRatio=N
survivor_space_size = new_size / (initial_survivor_ratio + 2) //survivor_space_size = new_size / (initial_survivor_ratio + 2)
//To keep the survivor spaces at a fixed size, set the SurvivorRatio to the desired value and disable the UseAdaptiveSizePolicy flag (though remember that disabling adaptive sizing will apply to the old and new generations as well).
-XX:TargetSurvivorRatio=N
-XX:InitialTenuringThreshold=N flag (the default is 7 for the throughput and G1 GC collectors, and 6 for CMS)
-XX:MaxTenuringThreshold=N flag; for the throughput and G1 GC collectors, the default maximum threshold is 15, and for CMS it is 6.
-XX:+AlwaysTenure //This is a rare situation; it means that objects will always be promoted to the old generation rather than stored in a survivor space.
-XX:+NeverTenure (also false by default).// This flag affects two things: it behaves as if the initial and max tenuring thresholds are infinity, and it prevents the JVM from adjusting that threshold down. In other words, as long as there is room in the survivor space, no object will ever be promoted to the old generation.
 -XX:+PrintTenuringDistribution (which is false by default). In JDK 11, it is added by including age*=debug or age*=trace to the Xlog argument.
 
 -XX:-UseTLAB
  -XX:+PrintTLAB //tlab*=trace 
  -XX:TLABSize=N (the default value, 0, means to use the dynamic calculation previously described)
  -XX:-ResizeTLAB (the default for that flag is true)
  -XX:TLABWasteTargetPercent=N
  -XX:TLABWasteIncrement=N (the default is 4)
  -XX:MinTLABSize=N (the default is 2 KB)
  